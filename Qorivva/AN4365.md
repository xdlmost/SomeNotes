> Qorivva MPC56xx Flash Programming Through Nexus/JTAG
# Qorivva MPC56xx系列 Nexus/JTAG闪存编程
> The Qorivva MPC56xx family of devices has internal
flash memory used for code and data. The MPC56xx
Nexus debug interface can be used to program flash
memory using the JTAG communication protocol
through the JTAG port. This allows programming of the
internal flash memory with an external tool.

Qorivva MPC56xx系列芯片拥有用于存储代码和数据的内建闪存。MPC56xx的Nexus调试接口可以用来为闪存编程，这需要连通JTAG接口，使用JTAG协议。这就是说可以通过外部工具对内建闪存进行编程。
> All MPC56xx devices have versions of the e200zx core
that support variable length encoding (VLE)
instructions. Most MPC56xx devices support both Book
E and VLE instructions; however, some MPC560x
devices utilize the e200z0 core that only supports VLE
instructions. Table 9 shows the core types used on
currently available MPC56xx devices. However, as
different variations of the MPC56xx family will be
released during the lifecycle of this document, it is
important that you confirm the core type on the target
MPC56xx device. For the remainder of this document,
code examples are provided in Book E. If the instruction
example differs when implemented in VLE, the
equivalent VLE instruction is also shown in brackets. 

所有MPC56xx系列芯片都包含一个支持变长编码指令集（下文称VLE）的e200zx内核。大多数MPC56xx系列芯片支持Book E和VLE两种指令集，一些使用了e200z0内核的芯片仅支持VLE指令集。`表9`列出了所有已发布芯片的内核型号，然而在本文档存续期间发布的新型号MPC56xx芯片不会被包含，请另行确认。本文中所有示例代码都会都以Book E指令集编写，如果对应的VLE指令与之不同会在其后的括号中提供。
> For further information on VLE, please consult VLEPM, Variable-Length Encoding (VLE) Programming
Environments Manual, available from freescale.com.

想进一步了解VLE指令集请参阅VLEPM（可以在freescale.com下载）

> This application note is adapted from AN3283, “MPC5500 Flash Programming Through Nexus/JTAG.” It
first addresses the JTAG and Nexus communication protocol. The JTAG discussion includes the JTAG
signals, TAP controller state machine, and the JTAG controller. The explanation of Nexus includes the
on-chip emulation (OnCE) module and the Nexus read/write (R/W) access block. As different versions of
the MPC56xx devices may use different JTAG and Nexus modules, the examples given here are generic
to suit this flash memory programming note. If more detailed information is required for a specific device,
please consult the reference manual.

这篇文档改编自最早阐述Nexus/JTAG通信协议的文章《MPC5500 Nexus/JTAG闪存编程》(AN3283).JTAG部分讨论了包括JTAG信号（JTAG signals）、TAP状态机和JTAG控制器。Nexus部分解释了仿真模块（OnCE）和Nexus块读写（Nexus R/W）。不同型号的MPC56xx系列芯片使用了不同的JTAG、Nexus模块，但是我们的示例代码仅适用于通用的flash。想了解某特定型号芯片的特性，请自行查看参考手册。
> After the communication protocols are described, this document goes into the details of the
Freescale-provided flash memory drivers and the requirements of the external tool for flash programming.
For the purpose of this document, the external tool consists of a PC application combined with interface
hardware that connects the PC to the JTAG port on an MPC56xx board or module.

解释通信协议后，本文档会进一步详解Freescale的flash设备和flash编程的外部工具需求。flash编程的外部工具即包含了软件，也包含了PC与MPC56xx系列芯片的JTAG链接的硬件接口
> This document is intended for anyone wanting to develop a flash memory programming tool for the
MPC56xx family of devices. Someone wanting to learn about the JTAG communication protocol, OnCE
module, or the Nexus R/W access block may also find this application note beneficial.

本文适用于所有有意向开发MPC56xx系列芯片的flash开发工具的人员，同时对想了解JTAG通信协议、仿真模块（OnCE）和Nexus块读写技术的开发在也有帮助。

>1 JTAG  JTAG is a serial communication protocol developed by the Joint Test Access Group. Originally developed
for boundary scan, JTAG is also used for communication with the Nexus debug interface (NDI) on the
MPC56xx devices. Figure 2 shows a block diagram of the NDI.

## 1 JTAG
JTAG是一系列有Joint Test Access Group开发的通信协议，其最初是用来做边界扫描（boundary scan）。同时JTAG也用作与MPC56xx系列芯片的NDI接口（Nexus debug interface）通信。`图2`显示了NDI的结构图。
>1.1 JTAG signals The JTAG port of the MPC56xx devices consists of the TCK, TDI, TDO, TMS, and JCOMP pins. TDI,TDO, TMS, and TCK are compliant with the IEEE 1149.1-2001 standard and are shared with the NDI through the test access port (TAP) interface. See Table 1 for signal properties. 

### 1.1 JTAG 信号（1.1 JTAG signals）
MPC56xx系列芯片的JTAG端口由 *TCK*, *TDI*, *TDO*, *TMS*, and *JCOMP* 引脚组成。其中*TCK*, *TDI*, *TDO*, *TMS*接口符合`IEEE 1149.1-2001`标准，同时这些针脚通过TAP接口可以与NDI共用。`表1`列出了引脚的定义。

|名称|输入or输出|功能|说明
|:-:|:-:|:-:|:-:|
|*TCK*|输入|时钟| |
|*TDI*|输入|数据输入| |
|*TDO*|输出|数据输出| |
|*TMS*|输入|模式选择| |
|*JCOMP*|输入|JTAG Compliancy|没有此引脚的芯片JTAG依旧可用，仅在5个时钟周期TMS高电位的情况下被重置|
|*RDY*|输出|Nexus/JTAG Ready|没有此引脚的芯片无法加速Nexus块转移操作|


>1.2 TAP controller state machine
The TAP controller state machine controls the JTAG logic. The TAP controller state machine is a 16-state
finite state machine (FSM) as shown in Figure 1. The TCK and TMS signals control transition between
states of the FSM. These two signals control whether an instruction register scan or data register scan is
performed. Both the TDI and TMS inputs are sampled on the rising edge of TCK while the TDO output
changes on the falling edge of TCK. The value shown next to each state of the state machine in Figure 1
is the value of TMS required on the rising edge of TCK to transition to the connected state. Five rising
edges of TCK with TMS at logic 1 guarantees entry into the TEST LOGIC RESET state.

### 1.2 TAP状态机
TAP状态机控制着JTAG逻辑。TAP状态机是有16个状态的有限状态机(FSM)，见`图1`。*TCK*和*TMS*信号共同控制着其状态的转换，同时也控制着是扫描指令寄存器还是数据寄存器。在*TCK*时钟上行期间会对*TDI*、*TMS*同时进行采样，下行期间改变改变*TDO*的输出。`图1`中显示了从当前状态切换到相关状态，所需在*TCK*时钟周期上行期间的*TMS*输入。从图中还可以看出不管当前是什么状态，*TMS*连续5个输入逻辑1都可以确保状态会切换到`TEST LOGIC RESET`,即重置状态。

![图1](Resource\Figure1.png)

>1.3 JTAG Controller (JTAGC) The devices in the MPC56xx family have a JTAG controller (JTAGC) that enables both boundary scan and
communication with the Nexus Development Interface (NDI). A block diagram of the NDI is shown in
Figure 2.

## 1.3 JTAG控制器 (JTAGC)
MPC56xx系列芯片都包含一个JTAG控制器(JTAGC)。通过JTAG控制器可以进行边界扫描（boundary scan）和与NDI（Nexus Development Interface）通信。`图2`为NDI的结构图：

![图1](Resource\Figure2.png)

>1.3.1 JTAGC reset The JTAGC is placed in reset when the TAP controller state machine is in the test logic reset state. The test
logic reset state is entered upon the assertion of the power-on reset signal, negation of JCOMP, or through
TAP controller state machine transitions controlled by TMS. Asserting power-on reset or negating JCOMP
results in asynchronous entry into the test logic reset state.
In devices without a JCOMP pin, the JTAGC is always enabled and can only be reset by clocking TCK
five times with TMS high. See AN4088, “MPC5500/MPC5600 Nexus Support Overview” for a table of
devices that implement the JCOMP pin.

### 1.3.1 重置JTAGC(JTAG控制器)
当TAP控制器的状态机处于`TEST LOGIC RESET`时，JTAGC就会被重置。只有接通电源和*JCOMP*异步输入导致的否定结果(negating JCOMP results)。

在没有*JCOMP*引脚的芯片上，JTAGC只能通过连续5次*TMS*输入逻辑1来重置。是否实现了*JCOMP*引脚，请参见*AN4088*《MPC5500/MPC5600 Nexus Support Overview》。

>1.3.2 TAP sharing
The JTAGC allows communication with the NDI by sharing the test access port (TAP) with other TAP
controllers. The JTAGC initially has control of the TAP after the assertion of power-on reset or the
negation of JCOMP. As an example, selectable NDI TAP controllers for the MPC5674F include the Nexus
port controller, e200z7 OnCE, eTPU Nexus, and eDMA Nexus. The NDI TAP controllers are selected by
loading the appropriate opcode into the 5-bit instruction register of the JTAGC while JCOMP is asserted.
Table 2 shows the opcodes for the selectable TAP controllers. The JTAGC instructions available will vary
slightly depending on the core type of the MPC56xx device being programmed; however, the important
factor in the context of this flash memory programming note is that the ACCESS_AUX_TAP_ONCE
opcode is the same on all MPC56xx devices. For further details on the device-specific JTAGC instructions,
please consult the individual reference manual

### 1.3.2 TAP共享

>When one of these opcodes is loaded, control of the TAP pins is transferred to the selected auxiliary TAP
controller. Any data input via TDI and TMS is passed to the selected TAP controller, and any TDO output
from the selected TAP controller is sent back to the JTAGC to be output on the TDO pin.

>The JTAGC regains control of the TAP during the UPDATE-DR state if the PAUSE-DR state was entered.
Auxiliary TAP controllers are held in RUN-TEST/IDLE while they are inactive. This document will focus
on the OnCE TAP controller. While access to the other TAP controllers is similar, they are outside the
scope of this document and are not needed for flash memory programming. 
